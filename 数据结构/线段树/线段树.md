# 线段树

原理：满二叉树，和堆相似，所以可以使用一个一维数组去存储整棵树，更具满二叉树的性质，我们有（假设倒数第二层有$n$个节点）：

1. 除最后一层外我们有$2n-1$个节点。
2. 最后一层最多有$2n$个节点
3. 总的节点数不会超过$4n-1$个节点

故在使用线段树时最少会开$4n$的空间

对于编号选择：
$$
\begin{cases}
    父节点——\frac{x}{2}\\
    左儿子——2x\\
    右儿子——2x+1
\end{cases}
$$

简单的线段树一般有五个操作

1. push_up：由父节点算子节点。
2. build：将一段区间初始化成线段树。
3. modify：修改操作 —— 修改单点或修改区间。
4. query：查询操作，即查询某一段线段树的信息。
5. push_down（懒标记、延迟标记）：由子节点算父节点。

## push_up

传入一个节点编号，用子节点信息计算父节点信息。

## build

代码一般形式：
```cpp
//u：当前节点编号
//l：当前区间的左端点
//r：当前区间的右端点
void build(int u, int L, int R)
{
    //将左右端点存入
    tr[u].l = L, tr[u].r = R;

    //如果当前节点为叶子节点，退出
    if(c == k) return;
    //计算当前区间中点
    int mid = L + R >> 1;
    build(u<<1, L, mid);
    build(u<<1|1, mid + 1, R);
    /*
    一般会在此时进行push_up操作
    push_up(u);
    */ 
}
```

## query

时间复杂度：$O(log_n)$

假设查询$[L, R]$ 区间的最大值。

在查询时，我们查询树中每个节点的范围，此时会有两种情况：

1. 树中节点所在范围在$[L, R]$内，即$[T_l, T_r]\subset[L, R]$ —— 直接返回区间$[T_l, T_r]$的属性值。
2. 有交集且交集不等于$[L, R]$，即$[L, R]\cap[T_l,T_r]\neq[L,R]\And \emptyset$ —— 继续递归左右两侧。

为了更清楚地说明查询的逻辑，我们举个例子 + 画图来理解，假设我们查询$[2， 7]之间的最大值$：

![0-1](./pic/0-1.png)

根据此图和查询逻辑，我们从头开始搜：
1. 第一层在范围外，加深搜索
2. 第二层的两个节点范围分别包含了所需范围的左端点和右端点，所以向合法范围递归
3. 第三层，范围4——5的节点直接返回其属性值，1——3、6——8继续递归加深
4. 到了第四层我们只剩下范围1——2需要递归加深
5. 如果看过我之前题解的同学能知道，我们直接从递归终点开始看，那么会发现例如区间$[2，3]$的属性值是通过比较区间$[2，2]$与区间$[3，3]$的属性值得出，那么此时会更容易理解代码的逻辑。

## 题一

![题一-1](./pic/Question1-1.png)
![题一-2](./pic/Question1-2.png)
![题一-3](./pic/Question1-3.png)

```cpp
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>

const int N = 200010;

int m, p;

struct Node
{
	int l, r;
	int v; //区间[l, r]中的最大值
}tr[N * 4];

//计算单个节点
void push_up(int u)
{
	tr[u].v = std::max(tr[u << 1].v, tr[u << 1 | 1].v);
}

//对线段树进行搭建
void build(int u, int L, int R)
{
	//将左右端点存入
	tr[u] = { L,R };

	//如果当前节点为叶子节点，退出
	if (L == R) return;
	//计算当前区间中点
	int mid = L + R >> 1;
    //u << 1 等价于 u * 2，u << 1|1 等价于 u * 2 + 1
    //向左递归建树，向右递归建树
    //相当于将区间不断二分直至区间变点
    //如此就能从递归终点向上处理区间属性，从而解决区间问题
	build(u << 1, L, mid);
	build(u << 1 | 1, mid + 1, R);
	/*
	一般会在此时进行push_up操作
	push_up(u);
	*/
}

//询问线段[L，R] 之间的属性，例如区间最值、区间和等等，一般从头节点开始
int query(int u, int l, int r)
{
    
	if (tr[u].l >= l && tr[u].r <= r) return tr[u].v;
	int mid = tr[u].l + tr[u].r >> 1;
	int v = 0;
	if (l <= mid) v = query(u << 1, l, r);
	if (r > mid) v = std::max(query(u << 1 | 1, l, r), v);
	return v;
}

void modify(int u, int x, int v)
{
	if (tr[u].l == x && tr[u].r == x) tr[u].v = v;
	else
	{
		int mid = tr[u].l + tr[u].r >> 1;
		if (x <= mid) modify(u << 1, x, v);
		else modify(u << 1 | 1, x, v);
		push_up(u);
	}
}

int main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);

	int n = 0, lasta = 0;
	std::cin >> m >> p;
	build(1, 1, m);

	int x;
	char op;
	while (m--)
	{
		std::cin >> op >> x;
		if (op == 'Q')
		{
			lasta = query(1, n - x + 1, n);
			std::cout << lasta << std::endl;
		}
		else
		{
			modify(1, n + 1, ((long long)lasta + x) % p);
			n++;
		}
	}
}
```

## 题二